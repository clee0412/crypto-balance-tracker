package edu.itba.cryptotracker.domain.entity.usercrypto;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;

import java.math.BigDecimal;
import java.util.UUID;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;
import static org.junit.jupiter.api.Assertions.*;

class UserCryptoTest {

    @Test
    @DisplayName("Should create UserCrypto with auto-generated ID and scaled quantity")
    void shouldCreateUserCryptoWithAutoGeneratedId() {
        // Given
        String userId = "user-123";
        BigDecimal quantity = new BigDecimal("10.12345");
        String platformId = "binance";
        String cryptoId = "bitcoin";

        // When
        UserCrypto userCrypto = UserCrypto.create(userId, quantity, platformId, cryptoId);

        // Then
        assertNotNull(userCrypto.getId());
        assertThat(userCrypto.getUserId(), is(userId));
        assertThat(userCrypto.getQuantity(), is(new BigDecimal("10.12"))); // Scaled to 2 decimal places
        assertThat(userCrypto.getPlatformId(), is(platformId));
        assertThat(userCrypto.getCryptoId(), is(cryptoId));
    }

    @Test
    @DisplayName("Should reconstitute UserCrypto with existing ID")
    void shouldReconstituteUserCrypto() {
        // Given
        UUID id = UUID.randomUUID();
        String userId = "user-456";
        BigDecimal quantity = new BigDecimal("25.50");
        String platformId = "coinbase";
        String cryptoId = "ethereum";

        // When
        UserCrypto userCrypto = UserCrypto.reconstitute(id, userId, quantity, platformId, cryptoId);

        // Then
        assertThat(userCrypto.getId(), is(id));
        assertThat(userCrypto.getUserId(), is(userId));
        assertThat(userCrypto.getQuantity(), is(quantity));
        assertThat(userCrypto.getPlatformId(), is(platformId));
        assertThat(userCrypto.getCryptoId(), is(cryptoId));
    }

    @Test
    @DisplayName("Should update quantity with scaling")
    void shouldUpdateQuantityWithScaling() {
        // Given
        UserCrypto userCrypto = UserCrypto.create("user-1", new BigDecimal("100"), "platform-1", "crypto-1");
        BigDecimal newQuantity = new BigDecimal("150.789");

        // When
        userCrypto.updateQuantity(newQuantity);

        // Then
        assertThat(userCrypto.getQuantity(), is(new BigDecimal("150.79"))); // Scaled to 2 decimal places
    }

    @Test
    @DisplayName("Should add quantity with scaling")
    void shouldAddQuantityWithScaling() {
        // Given
        UserCrypto userCrypto = UserCrypto.create("user-1", new BigDecimal("100.00"), "platform-1", "crypto-1");
        BigDecimal amountToAdd = new BigDecimal("50.555");

        // When
        userCrypto.addQuantity(amountToAdd);

        // Then
        assertThat(userCrypto.getQuantity(), is(new BigDecimal("150.56"))); // 100.00 + 50.555 = 150.555 -> 150.56
    }

    @Test
    @DisplayName("Should subtract quantity with scaling")
    void shouldSubtractQuantityWithScaling() {
        // Given
        UserCrypto userCrypto = UserCrypto.create("user-1", new BigDecimal("100.00"), "platform-1", "crypto-1");
        BigDecimal amountToSubtract = new BigDecimal("30.333");

        // When
        userCrypto.subtractQuantity(amountToSubtract);

        // Then
        assertThat(userCrypto.getQuantity(), is(new BigDecimal("69.67"))); // 100.00 - 30.333 = 69.667 -> 69.67
    }

    @Test
    @DisplayName("Should check sufficient balance correctly")
    void shouldCheckSufficientBalance() {
        // Given
        UserCrypto userCrypto = UserCrypto.create("user-1", new BigDecimal("100.00"), "platform-1", "crypto-1");

        // When/Then
        assertTrue(userCrypto.hasSufficientBalance(new BigDecimal("50.00")));
        assertTrue(userCrypto.hasSufficientBalance(new BigDecimal("100.00"))); // Exact amount
        assertFalse(userCrypto.hasSufficientBalance(new BigDecimal("100.01")));
        assertFalse(userCrypto.hasSufficientBalance(new BigDecimal("150.00")));
    }

    @Test
    @DisplayName("Should check zero balance correctly")
    void shouldCheckZeroBalance() {
        // Given
        UserCrypto zeroBalance = UserCrypto.create("user-1", BigDecimal.ZERO, "platform-1", "crypto-1");
        UserCrypto nonZeroBalance = UserCrypto.create("user-2", new BigDecimal("0.01"), "platform-1", "crypto-1");

        // When/Then
        assertTrue(zeroBalance.isZeroBalance());
        assertFalse(nonZeroBalance.isZeroBalance());
    }

    @Test
    @DisplayName("Should handle very small quantities")
    void shouldHandleVerySmallQuantities() {
        // Given
        UserCrypto userCrypto = UserCrypto.create("user-1", new BigDecimal("0.001"), "platform-1", "crypto-1");

        // Then
        assertThat(userCrypto.getQuantity(), is(new BigDecimal("0.00"))); // Scaled to 2 decimal places
        assertTrue(userCrypto.isZeroBalance());
    }

    @Test
    @DisplayName("Should implement equals and hashCode based on ID only")
    void shouldImplementEqualsAndHashCodeBasedOnId() {
        // Given
        UUID sharedId = UUID.randomUUID();
        UserCrypto userCrypto1 = UserCrypto.reconstitute(sharedId, "user-1", new BigDecimal("100"), "platform-1", "crypto-1");
        UserCrypto userCrypto2 = UserCrypto.reconstitute(sharedId, "user-2", new BigDecimal("200"), "platform-2", "crypto-2");
        UserCrypto userCrypto3 = UserCrypto.reconstitute(UUID.randomUUID(), "user-1", new BigDecimal("100"), "platform-1", "crypto-1");

        // Then
        assertThat(userCrypto1, is(equalTo(userCrypto2))); // Same ID, different other fields
        assertThat(userCrypto1, is(not(equalTo(userCrypto3)))); // Different ID
        assertThat(userCrypto1.hashCode(), is(userCrypto2.hashCode()));
        assertThat(userCrypto1.hashCode(), is(not(userCrypto3.hashCode())));
    }

    @Test
    @DisplayName("Should handle negative quantities")
    void shouldHandleNegativeQuantities() {
        // Given
        UserCrypto userCrypto = UserCrypto.create("user-1", new BigDecimal("50.00"), "platform-1", "crypto-1");

        // When - subtract more than available
        userCrypto.subtractQuantity(new BigDecimal("100.00"));

        // Then - quantity becomes negative
        assertThat(userCrypto.getQuantity(), is(new BigDecimal("-50.00")));
        assertFalse(userCrypto.hasSufficientBalance(BigDecimal.ONE));
        assertFalse(userCrypto.isZeroBalance());
    }

    @Test
    @DisplayName("Should implement toString")
    void shouldImplementToString() {
        // Given
        UserCrypto userCrypto = UserCrypto.create("user-123", new BigDecimal("10.50"), "binance", "bitcoin");

        // When
        String toString = userCrypto.toString();

        // Then
        assertThat(toString, containsString("user-123"));
        assertThat(toString, containsString("10.50"));
        assertThat(toString, containsString("binance"));
        assertThat(toString, containsString("bitcoin"));
    }

    @Test
    @DisplayName("Should handle rounding during operations")
    void shouldHandleRoundingDuringOperations() {
        // Given
        UserCrypto userCrypto = UserCrypto.create("user-1", new BigDecimal("10.00"), "platform-1", "crypto-1");

        // When - operations that require rounding
        userCrypto.addQuantity(new BigDecimal("0.333")); // 10.333 -> 10.33
        userCrypto.addQuantity(new BigDecimal("0.333")); // 10.663 -> 10.66
        userCrypto.addQuantity(new BigDecimal("0.333")); // 10.993 -> 10.99

        // Then
        assertThat(userCrypto.getQuantity(), is(new BigDecimal("10.99")));
    }
}