package edu.itba.cryptotracker.domain.entity.goal;

import edu.itba.cryptotracker.domain.entity.crypto.Crypto;
import edu.itba.cryptotracker.domain.entity.crypto.LastKnownPrices;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.BeforeEach;

import java.math.BigDecimal;
import java.util.UUID;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;
import static org.junit.jupiter.api.Assertions.*;

class GoalTest {

    private Crypto bitcoin;
    private Crypto ethereum;

    @BeforeEach
    void setUp() {
        bitcoin = Crypto.create(
                "bitcoin",
                "btc",
                "Bitcoin",
                "https://example.com/bitcoin.png",
                new LastKnownPrices(
                        new BigDecimal("45000.00"),
                        new BigDecimal("42000.00"),
                        new BigDecimal("1.0")
                )
        );

        ethereum = Crypto.create(
                "ethereum",
                "eth",
                "Ethereum",
                "https://example.com/ethereum.png",
                new LastKnownPrices(
                        new BigDecimal("3000.00"),
                        new BigDecimal("2800.00"),
                        new BigDecimal("0.07")
                )
        );
    }

    @Test
    @DisplayName("Should create goal with auto-generated ID")
    void shouldCreateGoalWithAutoGeneratedId() {
        // Given
        BigDecimal goalQuantity = new BigDecimal("10.0");

        // When
        Goal goal = Goal.create(bitcoin, goalQuantity);

        // Then
        assertNotNull(goal.getId());
        assertThat(goal.getId(), matchesPattern("[a-f0-9\\-]{36}"));
        assertThat(goal.getGoalQuantity(), is(goalQuantity));
        assertThat(goal.getCrypto(), is(bitcoin));
    }

    @Test
    @DisplayName("Should reconstitute goal with existing ID")
    void shouldReconstituteGoalWithExistingId() {
        // Given
        String existingId = UUID.randomUUID().toString();
        BigDecimal goalQuantity = new BigDecimal("5.0");

        // When
        Goal goal = Goal.reconstitute(existingId, goalQuantity, ethereum);

        // Then
        assertThat(goal.getId(), is(existingId));
        assertThat(goal.getGoalQuantity(), is(goalQuantity));
        assertThat(goal.getCrypto(), is(ethereum));
    }

    @Test
    @DisplayName("Should create new goal with updated quantity")
    void shouldCreateNewGoalWithUpdatedQuantity() {
        // Given
        Goal originalGoal = Goal.create(bitcoin, new BigDecimal("5.0"));
        BigDecimal newQuantity = new BigDecimal("10.0");

        // When
        Goal updatedGoal = originalGoal.withNewGoalQuantity(newQuantity);

        // Then
        assertThat(updatedGoal.getId(), is(originalGoal.getId()));
        assertThat(updatedGoal.getGoalQuantity(), is(newQuantity));
        assertThat(updatedGoal.getCrypto(), is(originalGoal.getCrypto()));
    }

    @Test
    @DisplayName("Should calculate progress correctly")
    void shouldCalculateProgressCorrectly() {
        // Given
        Goal goal = Goal.create(bitcoin, new BigDecimal("10.0"));

        // When/Then
        // 0% progress
        assertThat(goal.getProgress(BigDecimal.ZERO), is(0.0f));

        // 50% progress
        assertThat(goal.getProgress(new BigDecimal("5.0")), is(50.0f));

        // 75% progress
        assertThat(goal.getProgress(new BigDecimal("7.5")), is(75.0f));

        // 100% progress
        assertThat(goal.getProgress(new BigDecimal("10.0")), is(100.0f));

        // Over 100% (capped at 100)
        assertThat(goal.getProgress(new BigDecimal("15.0")), is(100.0f));
    }

    @Test
    @DisplayName("Should calculate remaining quantity correctly")
    void shouldCalculateRemainingQuantityCorrectly() {
        // Given
        Goal goal = Goal.create(ethereum, new BigDecimal("100.0"));

        // When/Then
        // Full amount remaining
        assertThat(goal.getRemainingQuantity(BigDecimal.ZERO), 
                is(new BigDecimal("100.0")));

        // Partial amount remaining
        assertThat(goal.getRemainingQuantity(new BigDecimal("30.0")), 
                is(new BigDecimal("70.0")));

        // No amount remaining (goal reached)
        assertThat(goal.getRemainingQuantity(new BigDecimal("100.0")), 
                is(BigDecimal.ZERO));

        // Over goal (still zero remaining)
        assertThat(goal.getRemainingQuantity(new BigDecimal("150.0")), 
                is(BigDecimal.ZERO));
    }

    @Test
    @DisplayName("Should calculate money needed based on current price")
    void shouldCalculateMoneyNeededCorrectly() {
        // Given
        Goal goal = Goal.create(bitcoin, new BigDecimal("2.0"));
        BigDecimal remainingQuantity = new BigDecimal("1.5");

        // When
        BigDecimal moneyNeeded = goal.getMoneyNeeded(remainingQuantity);

        // Then
        // 1.5 BTC * $45,000 = $67,500
        assertThat(moneyNeeded, is(new BigDecimal("67500.00")));
    }

    @Test
    @DisplayName("Should handle small quantities and precision")
    void shouldHandleSmallQuantitiesAndPrecision() {
        // Given
        Goal goal = Goal.create(bitcoin, new BigDecimal("0.001"));

        // When/Then
        assertThat(goal.getProgress(new BigDecimal("0.0005")), is(50.0f));
        assertThat(goal.getRemainingQuantity(new BigDecimal("0.0003")), 
                is(new BigDecimal("0.0007")));
    }

    @Test
    @DisplayName("Should implement equals and hashCode based on id, quantity, and crypto")
    void shouldImplementEqualsAndHashCode() {
        // Given
        String sharedId = UUID.randomUUID().toString();
        Goal goal1 = Goal.reconstitute(sharedId, new BigDecimal("10.0"), bitcoin);
        Goal goal2 = Goal.reconstitute(sharedId, new BigDecimal("10.0"), bitcoin);
        Goal goal3 = Goal.reconstitute(UUID.randomUUID().toString(), new BigDecimal("10.0"), bitcoin);
        Goal goal4 = Goal.reconstitute(sharedId, new BigDecimal("20.0"), bitcoin);

        // Then
        assertThat(goal1, is(equalTo(goal2)));
        assertThat(goal1, is(not(equalTo(goal3)))); // Different ID
        assertThat(goal1, is(not(equalTo(goal4)))); // Different quantity
        assertThat(goal1.hashCode(), is(goal2.hashCode()));
    }

    @Test
    @DisplayName("Should throw exception for null crypto")
    void shouldThrowExceptionForNullCrypto() {
        // When/Then
        assertThrows(NullPointerException.class, 
                () -> Goal.create(null, new BigDecimal("10.0")));
    }

    @Test
    @DisplayName("Should throw exception for null quantity")
    void shouldThrowExceptionForNullQuantity() {
        // When/Then
        assertThrows(NullPointerException.class, 
                () -> Goal.create(bitcoin, null));
    }
}